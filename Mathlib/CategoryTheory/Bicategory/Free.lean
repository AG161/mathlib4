/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.CategoryTheory.Bicategory.Functor

#align_import category_theory.bicategory.free from "leanprover-community/mathlib"@"3d7987cda72abc473c7cdbbb075170e9ac620042"

/-!
# Free bicategories

We define the free bicategory over a quiver. In this bicategory, the 1-morphisms are freely
generated by the arrows in the quiver, and the 2-morphisms are freely generated by the formal
identities, the formal unitors, and the formal associators modulo the relation derived from the
axioms of a bicategory.

## Main definitions

* `FreeBicategory B`: the free bicategory over a quiver `B`.
* `FreeBicategory.lift F`: the pseudofunctor from `FreeBicategory B` to `C` associated with a
  prefunctor `F` from `B` to `C`.
-/


universe w w‚ÇÅ w‚ÇÇ v v‚ÇÅ v‚ÇÇ u u‚ÇÅ u‚ÇÇ

namespace CategoryTheory

open Category Bicategory

open Bicategory

/-- Free bicategory over a quiver. Its objects are the same as those in the underlying quiver. -/
def FreeBicategory (B : Type u) :=
  B
#align category_theory.free_bicategory CategoryTheory.FreeBicategory

instance (B : Type u) : ‚àÄ [Inhabited B], Inhabited (FreeBicategory B) := by
  intro h
  exact id h

namespace FreeBicategory

section

variable {B : Type u} [Quiver.{v + 1} B]

/-- 1-morphisms in the free bicategory. -/
inductive Hom : B ‚Üí B ‚Üí Type max u v
  | of {a b : B} (f : a ‚ü∂ b) : Hom a b
  | id (a : B) : Hom a a
  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c
#align category_theory.free_bicategory.hom CategoryTheory.FreeBicategory.Hom

instance (a b : B) [Inhabited (a ‚ü∂ b)] : Inhabited (Hom a b) :=
  ‚ü®Hom.of default‚ü©

instance quiver : Quiver.{max u v + 1} (FreeBicategory B) where
  Hom := fun a b : B => Hom a b

instance categoryStruct : CategoryStruct.{max u v} (FreeBicategory B) where
  id   := fun a : B => Hom.id a
  comp := @fun _ _ _ => Hom.comp

/-- Representatives of 2-morphisms in the free bicategory. -/
-- porting note: no such linter
-- @[nolint has_nonempty_instance]
inductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v
  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f
  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h
  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :
      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.
  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)
  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))
  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)
  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f
  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))
  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f
  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)
#align category_theory.free_bicategory.hom‚ÇÇ CategoryTheory.FreeBicategory.Hom‚ÇÇ

section

-- porting note: commenting out redundant binder annotation update
-- variable {B}

-- mathport name: vcomp
-- The following notations are only used in the definition of `Rel` to simplify the notation.
local infixr:0 " ‚â´ " => Hom‚ÇÇ.vcomp

-- mathport name: id
local notation "ùüô" => Hom‚ÇÇ.id

-- mathport name: whisker_left
local notation f " ‚óÅ " Œ∑ => Hom‚ÇÇ.whisker_left f Œ∑

-- mathport name: whisker_right
local notation Œ∑ " ‚ñ∑ " h => Hom‚ÇÇ.whisker_right h Œ∑

-- mathport name: associator
local notation "Œ±_" => Hom‚ÇÇ.associator

-- mathport name: left_unitor
local notation "Œª_" => Hom‚ÇÇ.left_unitor

-- mathport name: right_unitor
local notation "œÅ_" => Hom‚ÇÇ.right_unitor

-- mathport name: associator_inv
local notation "Œ±‚Åª¬π_" => Hom‚ÇÇ.associator_inv

-- mathport name: left_unitor_inv
local notation "Œª‚Åª¬π_" => Hom‚ÇÇ.left_unitor_inv

-- mathport name: right_unitor_inv
local notation "œÅ‚Åª¬π_" => Hom‚ÇÇ.right_unitor_inv

/-- Relations between 2-morphisms in the free bicategory. -/
inductive Rel : ‚àÄ {a b : FreeBicategory B} {f g : a ‚ü∂ b}, Hom‚ÇÇ f g ‚Üí Hom‚ÇÇ f g ‚Üí Prop
  | vcomp_right {a b} {f g h : Hom a b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏‚ÇÅ Œ∏‚ÇÇ : Hom‚ÇÇ g h) :
      Rel Œ∏‚ÇÅ Œ∏‚ÇÇ ‚Üí Rel (Œ∑ ‚â´ Œ∏‚ÇÅ) (Œ∑ ‚â´ Œ∏‚ÇÇ)
  | vcomp_left {a b} {f g h : Hom a b} (Œ∑‚ÇÅ Œ∑‚ÇÇ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :
      Rel Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí Rel (Œ∑‚ÇÅ ‚â´ Œ∏) (Œ∑‚ÇÇ ‚â´ Œ∏)
  | id_comp {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (ùüô f ‚â´ Œ∑) Œ∑
  | comp_id {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Œ∑ ‚â´ ùüô g) Œ∑
  | assoc {a b} {f g h i : Hom a b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) (Œπ : Hom‚ÇÇ h i) :
      Rel ((Œ∑ ‚â´ Œ∏) ‚â´ Œπ) (Œ∑ ‚â´ Œ∏ ‚â´ Œπ)
  | whisker_left {a b c} (f : Hom a b) (g h : Hom b c) (Œ∑ Œ∑' : Hom‚ÇÇ g h) :
      Rel Œ∑ Œ∑' ‚Üí Rel (f ‚óÅ Œ∑) (f ‚óÅ Œ∑')
  | whisker_left_id {a b c} (f : Hom a b) (g : Hom b c) : Rel (f ‚óÅ ùüô g) (ùüô (f.comp g))
  | whisker_left_comp {a b c} (f : Hom a b) {g h i : Hom b c} (Œ∑ : Hom‚ÇÇ g h) (Œ∏ : Hom‚ÇÇ h i) :
      Rel (f ‚óÅ Œ∑ ‚â´ Œ∏) ((f ‚óÅ Œ∑) ‚â´ f ‚óÅ Œ∏)
  | id_whisker_left {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Hom.id a ‚óÅ Œ∑) (Œª_ f ‚â´ Œ∑ ‚â´ Œª‚Åª¬π_ g)
  | comp_whisker_left {a b c d} (f : Hom a b) (g : Hom b c) {h h' : Hom c d} (Œ∑ : Hom‚ÇÇ h h') :
     Rel (f.comp g ‚óÅ Œ∑) (Œ±_ f g h ‚â´ (f ‚óÅ g ‚óÅ Œ∑) ‚â´ Œ±‚Åª¬π_ f g h')
  | whisker_right {a b c} (f g : Hom a b) (h : Hom b c) (Œ∑ Œ∑' : Hom‚ÇÇ f g) :
      Rel Œ∑ Œ∑' ‚Üí Rel (Œ∑ ‚ñ∑ h) (Œ∑' ‚ñ∑ h)
  | id_whisker_right {a b c} (f : Hom a b) (g : Hom b c) : Rel (ùüô f ‚ñ∑ g) (ùüô (f.comp g))
  | comp_whisker_right {a b c} {f g h : Hom a b} (i : Hom b c) (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :
      Rel ((Œ∑ ‚â´ Œ∏) ‚ñ∑ i) ((Œ∑ ‚ñ∑ i) ‚â´ Œ∏ ‚ñ∑ i)
  | whisker_right_id {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Œ∑ ‚ñ∑ Hom.id b) (œÅ_ f ‚â´ Œ∑ ‚â´ œÅ‚Åª¬π_ g)
  | whisker_right_comp {a b c d} {f f' : Hom a b} (g : Hom b c) (h : Hom c d) (Œ∑ : Hom‚ÇÇ f f') :
      Rel (Œ∑ ‚ñ∑ g.comp h) (Œ±‚Åª¬π_ f g h ‚â´ ((Œ∑ ‚ñ∑ g) ‚ñ∑ h) ‚â´ Œ±_ f' g h)
  | whisker_assoc {a b c d} (f : Hom a b) {g g' : Hom b c} (Œ∑ : Hom‚ÇÇ g g') (h : Hom c d) :
      Rel ((f ‚óÅ Œ∑) ‚ñ∑ h) (Œ±_ f g h ‚â´ (f ‚óÅ Œ∑ ‚ñ∑ h) ‚â´ Œ±‚Åª¬π_ f g' h)
  | whisker_exchange {a b c} {f g : Hom a b} {h i : Hom b c} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ h i) :
      Rel ((f ‚óÅ Œ∏) ‚â´ Œ∑ ‚ñ∑ i) ((Œ∑ ‚ñ∑ h) ‚â´ g ‚óÅ Œ∏)
  | associator_hom_inv {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :
      Rel (Œ±_ f g h ‚â´ Œ±‚Åª¬π_ f g h) (ùüô ((f.comp g).comp h))
  | associator_inv_hom {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :
      Rel (Œ±‚Åª¬π_ f g h ‚â´ Œ±_ f g h) (ùüô (f.comp (g.comp h)))
  | left_unitor_hom_inv {a b} (f : Hom a b) : Rel (Œª_ f ‚â´ Œª‚Åª¬π_ f) (ùüô ((Hom.id a).comp f))
  | left_unitor_inv_hom {a b} (f : Hom a b) : Rel (Œª‚Åª¬π_ f ‚â´ Œª_ f) (ùüô f)
  | right_unitor_hom_inv {a b} (f : Hom a b) : Rel (œÅ_ f ‚â´ œÅ‚Åª¬π_ f) (ùüô (f.comp (Hom.id b)))
  | right_unitor_inv_hom {a b} (f : Hom a b) : Rel (œÅ‚Åª¬π_ f ‚â´ œÅ_ f) (ùüô f)
  | pentagon {a b c d e} (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :
      Rel ((Œ±_ f g h ‚ñ∑ i) ‚â´ Œ±_ f (g.comp h) i ‚â´ f ‚óÅ Œ±_ g h i)
        (Œ±_ (f.comp g) h i ‚â´ Œ±_ f g (h.comp i))
  | triangle {a b c} (f : Hom a b) (g : Hom b c) : Rel (Œ±_ f (Hom.id b) g ‚â´ f ‚óÅ Œª_ g) (œÅ_ f ‚ñ∑ g)
#align category_theory.free_bicategory.rel CategoryTheory.FreeBicategory.Rel

end

-- porting note: commenting out redundant binder annotation update
-- variable {B}

instance homCategory (a b : FreeBicategory B) : Category (a ‚ü∂ b) where
  Hom f g := Quot (@Rel _ _ a b f g)
  id f := Quot.mk Rel (Hom‚ÇÇ.id f)
  comp := @fun f g h => Quot.map‚ÇÇ Hom‚ÇÇ.vcomp Rel.vcomp_right Rel.vcomp_left
  id_comp := by
    rintro f g ‚ü®Œ∑‚ü©
    exact Quot.sound (Rel.id_comp Œ∑)
  comp_id := by
    rintro f g ‚ü®Œ∑‚ü©
    exact Quot.sound (Rel.comp_id Œ∑)
  assoc := by
    rintro f g h i ‚ü®Œ∑‚ü© ‚ü®Œ∏‚ü© ‚ü®Œπ‚ü©
    exact Quot.sound (Rel.assoc Œ∑ Œ∏ Œπ)
#align category_theory.free_bicategory.hom_category CategoryTheory.FreeBicategory.homCategory

/-- Bicategory structure on the free bicategory. -/
instance bicategory : Bicategory (FreeBicategory B) where
  homCategory := @fun (a b : B) => FreeBicategory.homCategory a b
  whiskerLeft := @fun a b c f g h Œ∑ => Quot.map (Hom‚ÇÇ.whisker_left f) (Rel.whisker_left f g h) Œ∑
  whiskerLeft_id := @fun a b c f g => Quot.sound (Rel.whisker_left_id f g)
  associator := @fun a b c d f g h =>
    { hom := Quot.mk Rel (Hom‚ÇÇ.associator f g h)
      inv := Quot.mk Rel (Hom‚ÇÇ.associator_inv f g h)
      hom_inv_id := Quot.sound (Rel.associator_hom_inv f g h)
      inv_hom_id := Quot.sound (Rel.associator_inv_hom f g h) }
  leftUnitor := @fun a b f =>
    { hom := Quot.mk Rel (Hom‚ÇÇ.left_unitor f)
      inv := Quot.mk Rel (Hom‚ÇÇ.left_unitor_inv f)
      hom_inv_id := Quot.sound (Rel.left_unitor_hom_inv f)
      inv_hom_id := Quot.sound (Rel.left_unitor_inv_hom f) }
  rightUnitor := @fun a b f =>
    { hom := Quot.mk Rel (Hom‚ÇÇ.right_unitor f)
      inv := Quot.mk Rel (Hom‚ÇÇ.right_unitor_inv f)
      hom_inv_id := Quot.sound (Rel.right_unitor_hom_inv f)
      inv_hom_id := Quot.sound (Rel.right_unitor_inv_hom f) }
  whiskerLeft_comp := by
    rintro a b c f g h i ‚ü®Œ∑‚ü© ‚ü®Œ∏‚ü©
    exact Quot.sound (Rel.whisker_left_comp f Œ∑ Œ∏)
  id_whiskerLeft := by
    rintro a b f g ‚ü®Œ∑‚ü©
    exact Quot.sound (Rel.id_whisker_left Œ∑)
  comp_whiskerLeft := by
    rintro a b c d f g h h' ‚ü®Œ∑‚ü©
    exact Quot.sound (Rel.comp_whisker_left f g Œ∑)
  whiskerRight := @fun a b c f g Œ∑ h => Quot.map (Hom‚ÇÇ.whisker_right h) (Rel.whisker_right f g h) Œ∑
  id_whiskerRight := @fun a b c f g => Quot.sound (Rel.id_whisker_right f g)
  comp_whiskerRight := by
    rintro a b c f g h ‚ü®Œ∑‚ü© ‚ü®Œ∏‚ü© i
    exact Quot.sound (Rel.comp_whisker_right i Œ∑ Œ∏)
  whiskerRight_id := by
    rintro a b f g ‚ü®Œ∑‚ü©
    exact Quot.sound (Rel.whisker_right_id Œ∑)
  whiskerRight_comp := by
    rintro a b c d f f' ‚ü®Œ∑‚ü© g h
    exact Quot.sound (Rel.whisker_right_comp g h Œ∑)
  whisker_assoc := by
    rintro a b c d f g g' ‚ü®Œ∑‚ü© h
    exact Quot.sound (Rel.whisker_assoc f Œ∑ h)
  whisker_exchange := by
    rintro a b c f g h i ‚ü®Œ∑‚ü© ‚ü®Œ∏‚ü©
    exact Quot.sound (Rel.whisker_exchange Œ∑ Œ∏)
  pentagon := @fun a b c d e f g h i => Quot.sound (Rel.pentagon f g h i)
  triangle := @fun a b c f g => Quot.sound (Rel.triangle f g)
#align category_theory.free_bicategory.bicategory CategoryTheory.FreeBicategory.bicategory

variable {a b c d : FreeBicategory B}

abbrev Hom‚ÇÇ.mk {f g : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) : f ‚ü∂ g :=
  Quot.mk Rel Œ∑

@[simp]
theorem mk_vcomp {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :
    (Œ∑.vcomp Œ∏).mk = (Œ∑.mk ‚â´ Œ∏.mk : f ‚ü∂ h) :=
  rfl
#align category_theory.free_bicategory.mk_vcomp CategoryTheory.FreeBicategory.mk_vcomp

@[simp]
theorem mk_whisker_left (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :
    (Hom‚ÇÇ.whisker_left f Œ∑).mk = (f ‚óÅ Œ∑.mk : f ‚â´ g ‚ü∂ f ‚â´ h) :=
  rfl
#align category_theory.free_bicategory.mk_whisker_left CategoryTheory.FreeBicategory.mk_whisker_left

@[simp]
theorem mk_whisker_right {f g : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (h : b ‚ü∂ c) :
    (Hom‚ÇÇ.whisker_right h Œ∑).mk = (Œ∑.mk ‚ñ∑ h : f ‚â´ h ‚ü∂ g ‚â´ h) :=
  rfl
#align category_theory.free_bicategory.mk_whisker_right CategoryTheory.FreeBicategory.mk_whisker_right

variable (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d)

-- Porting note: I can not get this to typecheck, and I don't understand why.
-- theorem id_def : Hom.id a = ùüô a :=
--   rfl
-- #align category_theory.free_bicategory.id_def CategoryTheory.FreeBicategory.id_def
#noalign category_theory.free_bicategory.id_def

theorem comp_def : Hom.comp f g = f ‚â´ g :=
  rfl
#align category_theory.free_bicategory.comp_def CategoryTheory.FreeBicategory.comp_def

@[simp]
theorem mk_id : Quot.mk _ (Hom‚ÇÇ.id f) = ùüô f :=
  rfl
#align category_theory.free_bicategory.mk_id CategoryTheory.FreeBicategory.mk_id

@[simp]
theorem mk_associator_hom : Quot.mk _ (Hom‚ÇÇ.associator f g h) = (Œ±_ f g h).hom :=
  rfl
#align category_theory.free_bicategory.mk_associator_hom CategoryTheory.FreeBicategory.mk_associator_hom

@[simp]
theorem mk_associator_inv : Quot.mk _ (Hom‚ÇÇ.associator_inv f g h) = (Œ±_ f g h).inv :=
  rfl
#align category_theory.free_bicategory.mk_associator_inv CategoryTheory.FreeBicategory.mk_associator_inv

@[simp]
theorem mk_left_unitor_hom : Quot.mk _ (Hom‚ÇÇ.left_unitor f) = (Œª_ f).hom :=
  rfl
#align category_theory.free_bicategory.mk_left_unitor_hom CategoryTheory.FreeBicategory.mk_left_unitor_hom

@[simp]
theorem mk_left_unitor_inv : Quot.mk _ (Hom‚ÇÇ.left_unitor_inv f) = (Œª_ f).inv :=
  rfl
#align category_theory.free_bicategory.mk_left_unitor_inv CategoryTheory.FreeBicategory.mk_left_unitor_inv

@[simp]
theorem mk_right_unitor_hom : Quot.mk _ (Hom‚ÇÇ.right_unitor f) = (œÅ_ f).hom :=
  rfl
#align category_theory.free_bicategory.mk_right_unitor_hom CategoryTheory.FreeBicategory.mk_right_unitor_hom

@[simp]
theorem mk_right_unitor_inv : Quot.mk _ (Hom‚ÇÇ.right_unitor_inv f) = (œÅ_ f).inv :=
  rfl
#align category_theory.free_bicategory.mk_right_unitor_inv CategoryTheory.FreeBicategory.mk_right_unitor_inv

/-- Canonical prefunctor from `B` to `free_bicategory B`. -/
@[simps]
def of : Prefunctor B (FreeBicategory B) where
  obj := id
  map := @fun _ _ => Hom.of
#align category_theory.free_bicategory.of CategoryTheory.FreeBicategory.of

end

section

variable {B : Type u‚ÇÅ} [Quiver.{v‚ÇÅ + 1} B] {C : Type u‚ÇÇ} [CategoryStruct.{v‚ÇÇ} C]

variable (F : Prefunctor B C)

/-- Auxiliary definition for `lift`. -/
@[simp]
def liftHom : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (F.obj a ‚ü∂ F.obj b)
  | _, _, Hom.of f => F.map f
  | _, _, Hom.id a => ùüô (F.obj a)
  | _, _, Hom.comp f g => liftHom f ‚â´ liftHom g
#align category_theory.free_bicategory.lift_hom CategoryTheory.FreeBicategory.liftHom

@[simp]
theorem liftHom_id (a : FreeBicategory B) : liftHom F (ùüô a) = ùüô (F.obj a) :=
  rfl
#align category_theory.free_bicategory.lift_hom_id CategoryTheory.FreeBicategory.liftHom_id

@[simp]
theorem liftHom_comp {a b c : FreeBicategory B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) :
    liftHom F (f ‚â´ g) = liftHom F f ‚â´ liftHom F g :=
  rfl
#align category_theory.free_bicategory.lift_hom_comp CategoryTheory.FreeBicategory.liftHom_comp

end

section

variable {B : Type u‚ÇÅ} [Quiver.{v‚ÇÅ + 1} B] {C : Type u‚ÇÇ} [Bicategory.{w‚ÇÇ, v‚ÇÇ} C]

variable (F : Prefunctor B C)

/-- Auxiliary definition for `lift`. -/
-- @[simp] -- Porting note: adding `@[simp]` causes a PANIC.
def liftHom‚ÇÇ : ‚àÄ {a b : FreeBicategory B} {f g : a ‚ü∂ b}, Hom‚ÇÇ f g ‚Üí (liftHom F f ‚ü∂ liftHom F g)
  | _, _, _, _, Hom‚ÇÇ.id _ => ùüô _
  | _, _, _, _, Hom‚ÇÇ.associator _ _ _ => (Œ±_ _ _ _).hom
  | _, _, _, _, Hom‚ÇÇ.associator_inv _ _ _ => (Œ±_ _ _ _).inv
  | _, _, _, _, Hom‚ÇÇ.left_unitor _ => (Œª_ _).hom
  | _, _, _, _, Hom‚ÇÇ.left_unitor_inv _ => (Œª_ _).inv
  | _, _, _, _, Hom‚ÇÇ.right_unitor _ => (œÅ_ _).hom
  | _, _, _, _, Hom‚ÇÇ.right_unitor_inv _ => (œÅ_ _).inv
  | _, _, _, _, Hom‚ÇÇ.vcomp Œ∑ Œ∏ => liftHom‚ÇÇ Œ∑ ‚â´ liftHom‚ÇÇ Œ∏
  | _, _, _, _, Hom‚ÇÇ.whisker_left f Œ∑ => liftHom F f ‚óÅ liftHom‚ÇÇ Œ∑
  | _, _, _, _, Hom‚ÇÇ.whisker_right h Œ∑ => liftHom‚ÇÇ Œ∑ ‚ñ∑ liftHom F h
#align category_theory.free_bicategory.lift_hom‚ÇÇ CategoryTheory.FreeBicategory.liftHom‚ÇÇ

attribute [local simp] whisker_exchange

theorem liftHom‚ÇÇ_congr {a b : FreeBicategory B} {f g : a ‚ü∂ b} {Œ∑ Œ∏ : Hom‚ÇÇ f g} (H : Rel Œ∑ Œ∏) :
    liftHom‚ÇÇ F Œ∑ = liftHom‚ÇÇ F Œ∏ := by induction H <;> (dsimp [liftHom‚ÇÇ]; aesop_cat)
#align category_theory.free_bicategory.lift_hom‚ÇÇ_congr CategoryTheory.FreeBicategory.liftHom‚ÇÇ_congr

/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from
`free_bicategory B` to `C`.
-/
@[simps]
def lift : Pseudofunctor (FreeBicategory B) C where
  obj := F.obj
  map := liftHom F
  mapId a := Iso.refl _
  mapComp f g := Iso.refl _
  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun Œ∑ Œ∏ H => liftHom‚ÇÇ_congr F H
  -- Porting note: We'd really prefer not to be doing this by hand.
  -- in mathlib3 `tidy` did these inductions for us.
  map‚ÇÇ_comp := by
    intros a b f g h Œ∑ Œ∏
    apply Quot.rec _ _ Œ∑
    intro Œ∑
    apply Quot.rec _ _ Œ∏
    intro Œ∏; rfl
    intros; rfl
    intros; rfl
  -- Porting note: still borked from here. The infoview doesn't update properly for me.
  map‚ÇÇ_whisker_left := by
    intro a b c f g h Œ∑
    apply Quot.rec _ _ Œ∑
    intros; aesop_cat
    intros; rfl
  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; apply Quot.rec _ _ Œ∑ <;> aesop_cat
#align category_theory.free_bicategory.lift CategoryTheory.FreeBicategory.lift

end

end FreeBicategory

end CategoryTheory
